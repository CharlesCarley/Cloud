    
    public class ${ClassName} {

        public const int UniqueIdentifier = ${UniqueId};

        [PrimaryKey, AutoIncrement]
        public int     ServerId { get; set; } = Constants.Undefined;
        public int     Revision { get; set; } = Constants.Undefined;
        public string  Key      { get; set; } = string.Empty;
        public string  Storage  { get; set; } = string.Empty;

        [Ignore]
        public static SQLiteConnection Connection => Database.Connection;
        [Ignore]
        public static bool IsConnected => Database.IsConnected;
        [Ignore]
        public static TableQuery<${ClassName}> Query => Database.Connection?.Table<${ClassName}>();

        public static void Clear() 
        {
            if (!IsConnected) 
                return;
            Connection?.DropTable<${ClassName}>();
            Connection?.CreateTable<${ClassName}>();
        }

        public static void Register() 
        {
            Connection?.CreateTable<${ClassName}>();
        }
        
        private static RevisionId ExtractIdRevFromDatabase(string key) 
        {
            if (!IsConnected || string.IsNullOrEmpty(key))
                return null;

            var result = Connection.Query<RevisionId>(
                "SELECT ServerId, Revision FROM ${ClassName} WHERE Key==?;", key);

            if (result != null && result.Count > 0)
                return result[0];
            return null;
        }

        public static bool Save(${ClassName} obj) 
        {
            if (!IsConnected || obj is null)
                return false;

            var result = false;
            try {
                if (Query.All(i => i.Key != obj.Key)) {
                    // Re-examine this but keep for now, 
                    // It allows objects to be saved 'without' a lookup key.
                    // Which is can be a desired behavior, but the means for generating 
                    // the key needs to be better.
                    if (string.IsNullOrEmpty(obj.Key))
                        obj.Key = Database.GenerateKey();

                    obj.Revision = 1;
                    result = Connection?.Insert(obj) != 0;
                } else {
                    var id = ExtractIdRevFromDatabase(obj.Key);
                    if (id != null) {
                        obj.ServerId = id.ServerId;
                        obj.Revision = id.Revision + 1;

                        // TODO: Compare the package strings for equality, and if they are not the same 
                        //       do the update....
                        result = Connection?.Update(obj) != 0;
                    } else {

                        LogUtils.Log(LogLevel.Warn,
                            nameof(Save),
                            $"Failed to extract ServerId and Revision from the ${ClassName} table, with the key '{obj.Key}'");
                    }
                }
            } catch (SQLiteException ex) {
                result = false;

                LogUtils.Log(LogLevel.Error,
                    nameof(Save),
                    ex.Message);
            }

            // TODO: return the json {"ServerId": ServerId, "Revision": Revision }
            // for now it's just a bool value...
            return result;
        }


        public static string AsJson64(${ClassName} obj) 
        {
            if (obj is null)
                return string.Empty;
            var json = new JsonObject();
            json.AddValue("ServerId", obj.ServerId);
            json.AddValue("Revision", obj.Revision);
            json.AddValue("Package",  obj.Storage);
            return json.AsBase64();
        }

    }

    public class ${ClassName}Controller : Controller 
    {
        [Ignore]
        public static TableQuery<${ClassName}> Query => 
            Database.Connection?.Table<${ClassName}>();


        /// <summary>
        /// Attempts to select all pairs of [ServerId, Revision] codes 
        /// from the database.
        /// </summary>
        /// <returns>
        ///  If not connected: an empty string list '[]' otherwise a list
        ///  formatted as: id[0], rev[0], ... id[n], rev[n]
        /// </returns>
        [Route("${SelectArray}/${UniqueId}")] [HttpGet]
        public string SelectArray() 
        {
            // First, try to connect.
            Database.Connect();

            if (!Database.IsConnected) {

                LogUtils.Log(LogLevel.Warn, 
                    nameof(SelectArray), 
                    "no connection to the database.");

                // cant do it so bail out with an empty list.
                return Constants.ReturnNone;
            }

            // pull all items 
            var result = Database.Connection?.Query<RevisionId>(
                "SELECT ServerId, Revision FROM ${ClassName};");

            string returnString  = null;

            if (result != null && result.Count > 0) {

                // Build a CSV list formatted as: id[0], rev[0], ... id[n], rev[n]

                var list = new List<int>();
                foreach (var id in result) {
                    list.Add(id.ServerId);
                    list.Add(id.Revision);
                }

                returnString = StringUtils.IntListToString(list, true);
            } else {
                returnString = Constants.ReturnNone;
            }
            Database.Close();
            return returnString;
        }

        [Route("${ContainsKey}/${UniqueId}")] [HttpPost]
        public string ContainsKey([FromBody] PostBundle bundle) 
        {
            // fail cases: the bundle is null or its content is empty.  

            if (bundle is null) {
                LogUtils.Log(LogLevel.Warn, 
                    nameof(ContainsKey), 
                    "the supplied bundle is null");
                return Constants.ReturnFailure;
            }

            if (string.IsNullOrEmpty(bundle.Content)) {
                LogUtils.Log(LogLevel.Warn, 
                    nameof(ContainsKey), 
                    "Missing bundle content");
                return Constants.ReturnFailure;
            }


            // extract the content back out

            var lookupKey = StringUtils.FromBase64(bundle.Content);
            if (string.IsNullOrEmpty(lookupKey))  {

                LogUtils.Log(LogLevel.Error, 
                    nameof(ContainsKey), 
                    "Failed to extract bundle content.");
                return Constants.ReturnFailure;
            }

            // try to connect and query it

            Database.Connect();
            var item   = Query?.FirstOrDefault(obj => obj.Key == lookupKey) != null;
            var result = item ? Constants.ReturnTrue : Constants.ReturnFalse;
            Database.Close();
            return result;
        }


        [Route("${SelectById}/${UniqueId}")] [HttpPost]
        public string SelectById([FromBody] PostBundle bundle) 
        {
            if (bundle is null)
                return null;

            var identifier = StringUtils.ToInt(
                StringUtils.FromBase64(bundle.Content),
                Constants.Undefined);

            if (identifier == Constants.Undefined) 
                return null;
            
            Database.Connect();
            var item = Query?.FirstOrDefault(obj => obj.ServerId == identifier);
            string result = null;
            if (item != null)
                result = ${ClassName}.AsJson64(item);
            Database.Close();
            return result;
        }

        [Route("${SelectByKey}/${UniqueId}")] [HttpPost]
        public string SelectByKey([FromBody] PostBundle bundle) 
        {
            if (bundle is null)
                return null;

            var identifier = StringUtils.FromBase64(bundle.Content);
            if (string.IsNullOrEmpty(identifier)) 
                return null;
            
            Database.Connect();
            var item = Query?.FirstOrDefault(obj => obj.Key == identifier);
            string result = null;
            if (item != null)
                result = ${ClassName}.AsJson64(item);
            Database.Close();
            return result;
        }

        [Route("${Save}/${UniqueId}")] [HttpPost]
        public void Save([FromBody] PostBundle bundle) 
        {
            if (bundle is null)
                return;

            Database.Connect();
            var obj = (UnpackedBundle)JsonParser.Unwrap(
                    bundle.Content, 
                    typeof(UnpackedBundle));
            if (obj == null)
                return;
            ${ClassName}.Save(new ${ClassName}{
                ServerId = obj.ServerId,
                Revision = obj.Revision,
                Key      = obj.Key,
                Storage  = obj.Package,
            });

            // TODO: Return the id and the revision..
            Database.Close();
        }

        [Route("${Drop}/${UniqueId}")] [HttpPost]
        public void Drop([FromBody] PostBundle bundle) 
        {
            if (bundle is null)
                return;

            var identifier = StringUtils.FromBase64(bundle.Content);
            if (string.IsNullOrEmpty(identifier)) 
                return;
            
            Database.Connect();
            var item = Query?.FirstOrDefault(obj => obj.Key == identifier);
            if (item != null)
                Database.Connection?.Delete(item);
            Database.Close();
        }

        [Route("${Clear}/${UniqueId}")] [HttpPost]
        public void Clear([FromBody] PostBundle bundle) 
        {
            Database.Connect();
            ${ClassName}.Clear();
            Database.Close();
        }
    }